# AI_Brain.gd
extends Node

class_name AI_Brain

@export var input_size: int = 3
@export var output_size: int = 2
@export var layer_sizes: Array = [4, 4] # hidden layers
@export var algorithm: String = "simple" # only 'simple' for now

# Neural network weights and biases
var weights: Array = []
var biases: Array = []

func _ready():
    _initialize_network()

func _initialize_network():
    # Initialize weights and biases for each layer
    var layer_input_size = input_size
    for size in layer_sizes:
        weights.append(_create_matrix(size, layer_input_size))
        biases.append(_create_vector(size))
        layer_input_size = size
    # Output layer
    weights.append(_create_matrix(output_size, layer_input_size))
    biases.append(_create_vector(output_size))

func _create_matrix(rows, cols):
    var matrix = []
    for _ in range(rows):
        var row = []
        for _ in range(cols):
            row.append(randf_range(-1, 1))
        matrix.append(row)
    return matrix

func _create_vector(size):
    var vec = []
    for _ in range(size):
        vec.append(randf_range(-1, 1))
    return vec

# Forward pass
func predict(inputs: Array) -> Array:
    var activations = inputs
    for i in range(weights.size()):
        var z = _matvec_mul(weights[i], activations)
        z = _vec_add(z, biases[i])
        activations = _relu(z)
    return activations

func _matvec_mul(matrix: Array, vector: Array) -> Array:
    var result = []
    for row in matrix:
        var sum = 0.0
        for i in range(len(vector)):
            sum += row[i] * vector[i]
        result.append(sum)
    return result

func _vec_add(vec1: Array, vec2: Array) -> Array:
    var result = []
    for i in range(len(vec1)):
        result.append(vec1[i] + vec2[i])
    return result

func _relu(vec: Array) -> Array:
    var result = []
    for v in vec:
        result.append(max(0, v))
    return result

# Set inputs
var input_array: Array = []

func set_inputs(inputs: Array):
    if inputs.size() != input_size:
        push_error("Input size mismatch")
    else:
        input_array = inputs

# Set reward function (can be used externally)
var reward: float = 0.0

func set_reward(r: float):
    reward = r

# Get output array
func get_output() -> Array:
    if input_array.size() == 0:
        push_error("Inputs not set")
        return []
    return predict(input_array)

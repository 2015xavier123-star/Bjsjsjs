extends Node
class_name AI_Brain

@export var input_size: int = 3
@export var output_size: int = 2
@export var layer_sizes: Array = [4, 4] # hidden layers
@export var algorithm: String = "simple" # only 'simple' for now

var weights: Array = []
var biases: Array = []

# File path for saving/loading the model
const MODEL_FILE_PATH := "res://model_save.json"

# Inputs
var input_array: Array = []

# Reward (kept at 0 for external configuration)
var reward: float = 0.0

func _ready():
    # Load model if exists
    if FileAccess.file_exists(MODEL_FILE_PATH):
        _load_model()
    else:
        _initialize_network()

func _initialize_network():
    weights.clear()
    biases.clear()
    var layer_input_size = input_size
    for size in layer_sizes:
        weights.append(_create_matrix(size, layer_input_size))
        biases.append(_create_vector(size))
        layer_input_size = size
    # Output layer
    weights.append(_create_matrix(output_size, layer_input_size))
    biases.append(_create_vector(output_size))
    # Save the initialized model
    _save_model()

func _create_matrix(rows, cols):
    var matrix = []
    for _ in range(rows):
        var row = []
        for _ in range(cols):
            row.append(randf_range(-1, 1))
        matrix.append(row)
    return matrix

func _create_vector(size):
    var vec = []
    for _ in range(size):
        vec.append(randf_range(-1, 1))
    return vec

# Forward pass
func predict(inputs: Array) -> Array:
    var activations = inputs
    for i in range(weights.size()):
        var z = _matvec_mul(weights[i], activations)
        z = _vec_add(z, biases[i])
        activations = _relu(z)
    return activations

func _matvec_mul(matrix: Array, vector: Array) -> Array:
    var result = []
    for row in matrix:
        var sum = 0.0
        for i in range(len(vector)):
            sum += row[i] * vector[i]
        result.append(sum)
    return result

func _vec_add(vec1: Array, vec2: Array) -> Array:
    var result = []
    for i in range(len(vec1)):
        result.append(vec1[i] + vec2[i])
    return result

func _relu(vec: Array) -> Array:
    var result = []
    for v in vec:
        result.append(max(0, v))
    return result

# Set inputs
func set_inputs(inputs: Array):
    if inputs.size() != input_size:
        push_error("Input size mismatch")
    else:
        input_array = inputs

# Set reward (can be used externally)
func set_reward(r: float):
    reward = r

# Get output array
func get_output() -> Array:
    if input_array.size() == 0:
        push_error("Inputs not set")
        return []
    return predict(input_array)

# Save model weights and biases to file
func _save_model():
    var data = {
        "weights": weights,
        "biases": biases
    }
    var file = FileAccess.open(MODEL_FILE_PATH, FileAccess.WRITE)
    if file:
        file.store_string(to_json(data))
        file.close()

# Load model weights and biases from file
func _load_model():
    var file = FileAccess.open(MODEL_FILE_PATH, FileAccess.READ)
    if file:
        var json_str = file.get_as_text()
        var data = parse_json(json_str)
        if data and data.has("weights") and data.has("biases"):
            weights = data["weights"]
            biases = data["biases"]
        else:
            push_error("Invalid model file, reinitializing network")
            _initialize_network()
        file.close()
